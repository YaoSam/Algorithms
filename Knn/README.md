#KNN算法改进实验

##基本思路
KNN本质就是对集合的一个划分。只是划分的界并不确定。  
跟排序类似，可以用排序解决，但是问题实际上比排序要简单，因为排序得到的整个集合的序时没有必要的。  
我们的KNN算法都是参考排序的想法来做。通过简化的排序操作来得到前k个元素。  
并且通过结合不同的算法从而得到一个平均性能较好的KNN算法。

---------

##算法说明

### 算法1 堆排序-维护前k个序列
扫描一遍后n-k个元素。维护前k个序列的最大值。显然。扫描完后，后面n-k个都比前面k个元素要大。
这里的优化的关键在于怎样快速地维护最大值。  
1. 最简单的做法是每次都遍历前ｋ个元素得到最大值。显然不可取。
 - 复杂度O(n*k)  
2. 第二种做法是对前ｋ个元素排序(从大到小)，这样第一个元素就是最大值。每次也只要将比较元素插入到对应位置即可。可以理解为简化版的插入排序。这里虽然加快了最大值的查找。增加的花销是维护前K个元素的序。其实对KNN来说也是没必要的。
 - 复杂度O(n)~O(n*k)
3. 第三种做法是先在前k元素建立最大堆。首个元素也是最大值。  
每次替换后也只需要在从上到下维护堆即可。可以看作简化版的堆排序。姑且命名为堆排式knn。  


- **复杂度**：O(n)~O(n\*log(k))  
- **优点**：k较小时效率很高。尤其是k=1时，为O(n)。  
- **缺点**：  
 - k较大时效率较低。
 - 不稳定，数据不太好的时候容易退化成O(n*log(k))的情况。


### 算法2 快排-通过不断划分：
随机选取一个元素对数组进行划分。再对k所在的一边进行划分。不断进行直到刚好分出前k个元素。  
可以理解为简化版的快排（相当于只进行快排的一个分支）。  
姑且命名为快排式knn。  
由于只需要进行一个分支的划分。所以没有用递归实现。直接用了循环。
- **复杂度**：O(n)~O(n^2)。  
- **优点**：	相对较为稳定。并且效率受k影响很少。（k较大的时候效率相对较高）  
- **缺点**：	
 - 效率收k影响很少。（k较小的时候效率相对较低）  
 - 面对不好的数据会退化成冒泡排序……O(n^2)…… 


### 2.3	算法3 Introspective KNN ★

结合了前面两种算法的。取其所长。  
在快排式knn的递归进入到一定深度或者k相对n较小的情况下转化为堆排式knn。  
即防止快排式knn退化成O(n^2)，也防止了堆排式knn遇到k比较大的情况或者数据比较不好的情况。  
从而得到一种**平均性能较好**的算法。

其实我们总体是参考了C++内置排序sort的实现。  
参考：<http://www.udpwork.com/item/12284.html>